#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import logging
import os

import configparser
import nagiosplugin
import nagiosplugin.result
import nagiosplugin.state
import pysnmp.smi

import ups_apc_snmp
import ups_apc_snmp.snmpclient

MIB_PATH = os.path.realpath(os.path.dirname(ups_apc_snmp.__file__))

_log = logging.getLogger('nagiosplugin')


class PerformanceContext(nagiosplugin.Context):  # pylint: disable=too-few-public-methods
	def __init__(self, name, fmt_metric='{name} is {valueunit}', result_cls=nagiosplugin.result.Result):  # pylint: disable=too-many-arguments
		super(PerformanceContext, self).__init__(name, fmt_metric, result_cls)

	def performance(self, metric, resource):
		return nagiosplugin.performance.Performance(metric.name, metric.value)

	def evaluate(self, metric, resource):
		return self.result_cls(nagiosplugin.state.Ok, None, metric)


class BoolContext(nagiosplugin.Context):  # pylint: disable=too-few-public-methods
	def __init__(self, name, ok_text=None, crit_text=None, fmt_metric='{name} is {valueunit}', result_cls=nagiosplugin.result.Result):  # pylint: disable=too-many-arguments
		self.ok_text = ok_text
		self.crit_text = crit_text
		super(BoolContext, self).__init__(name, fmt_metric, result_cls)

	def evaluate(self, metric, resource):
		if metric.value:
			return self.result_cls(nagiosplugin.state.Ok, self.ok_text, metric)
		else:
			return self.result_cls(nagiosplugin.state.Critical, self.crit_text, metric)


class BoolContextWarning(BoolContext):  # pylint: disable=too-few-public-methods
	def __init__(self, name, ok_text=None, warn_text=None, fmt_metric='{name} is {valueunit}', result_cls=nagiosplugin.result.Result):  # pylint: disable=too-many-arguments
		self.ok_text = ok_text
		self.warn_text = warn_text
		super(BoolContextWarning, self).__init__(name, fmt_metric, result_cls)

	def evaluate(self, metric, resource):
		if metric.value:
			return self.result_cls(nagiosplugin.state.Ok, self.ok_text, metric)
		else:
			return self.result_cls(nagiosplugin.state.Warn, self.warn_text, metric)


class ElementContext(nagiosplugin.Context):  # pylint: disable=too-few-public-methods
	def __init__(self, name, ok_text=None, warn_text=None, crit_text=None, unknown_text=None, ok_values=None, warn_values=None, crit_values=None, fmt_metric='{name} is {valueunit}', result_cls=nagiosplugin.result.Result):  # pylint: disable=too-many-arguments
		self.ok_text = ok_text
		self.warn_text = warn_text
		self.crit_text = crit_text
		self.unknown_text = unknown_text
		self.ok_values = ok_values or []
		self.warn_values = warn_values or []
		self.crit_values = crit_values or []
		super(ElementContext, self).__init__(name, fmt_metric, result_cls)

	def evaluate(self, metric, resource):
		if metric.value in self.ok_values:
			return self.result_cls(nagiosplugin.state.Ok, self.ok_text, metric)
		elif metric.value in self.warn_values:
			return self.result_cls(nagiosplugin.state.Warn, self.crit_text, metric)
		elif metric.value in self.crit_values:
			return self.result_cls(nagiosplugin.state.Critical, self.crit_text, metric)
		else:
			return self.result_cls(nagiosplugin.state.Unknown, self.unknown_text, metric)


class SNMPContext(nagiosplugin.Context):  # pylint: disable=too-few-public-methods
	def evaluate(self, metric, resource):
		if metric.value["status"]:
			return self.result_cls(nagiosplugin.state.Ok, None, metric)
		else:
			return self.result_cls(nagiosplugin.state.Critical, "Unreachable - %s" % metric.value["error_indication"], metric)


class UPSAPC(nagiosplugin.Resource):  # pylint: disable=too-few-public-methods
	def __init__(self, args):
		self.args = args
		ups_apc_snmp.snmpclient.add_mib_path(MIB_PATH)
		self.snmpclient = None

	def probe(self):  # pylint: disable=too-many-locals
		mib_builder = pysnmp.smi.builder.MibBuilder()
		mib_sources = mib_builder.getMibSources() + (pysnmp.smi.builder.DirMibSource(MIB_PATH),)
		mib_builder.setMibSources(*mib_sources)
		mib_builder.loadModules("SNMPv2-MIB")
		mib_builder.loadModules("PowerNet-MIB")

		_log.debug("Probing APC UPS device %s through SNMP", self.args.host)
		self.snmpclient = ups_apc_snmp.snmpclient.SnmpClient(self.args.host, ups_apc_snmp.snmpclient.snmp_auth_data_v2c(community=self.args.community), timeout=self.args.snmp_timeout, retries=self.args.retries)

		if not self.snmpclient.alive:
			_log.warn("Device is not reachable through SNMP with error %s", self.snmpclient.error_status)
			yield nagiosplugin.Metric('reachable', dict(status=self.snmpclient.alive, error_indication=self.snmpclient.error_indication, error_status=self.snmpclient.error_status, error_varbinds=self.snmpclient.error_varbinds))
			return

		_log.debug("Queried APC UPS device %s through SNMP - device is reachable", self.args.host)
		yield nagiosplugin.Metric('reachable', dict(status=True))
		_log.debug("Found Sysname %s and sysdescr %s", self.snmpclient.sysname, self.snmpclient.sysdescr)

		if not str(self.snmpclient.sysdescr).startswith("APC"):
			raise nagiosplugin.CheckError("Device is not a APC UPS device - System description is %s", self.snmpclient.sysdescr)

		_log.debug("Starting SNMP polling of host %s", self.args.host)

		sysuptime = self.snmpclient.get("SNMPv2-MIB::sysUpTime.0")

		yield nagiosplugin.Metric("sysuptime", int(sysuptime.get_value() / 100 / 60))

		# device
		unit_type = self.snmpclient.get("PowerNet-MIB::upsBasicIdentModel.0").get_value()
		_log.debug("Device %s unit type is %s", self.args.host, unit_type)

		# battery
		battery_capacity = self.snmpclient.get("PowerNet-MIB::upsAdvBatteryCapacity.0").get_value()
		_log.debug("Device %s battery capacity is %d%%", self.args.host, battery_capacity)

		battery_voltage = self.snmpclient.get("PowerNet-MIB::upsAdvBatteryActualVoltage.0").get_value()
		_log.debug("Device %s battery voltage is %dV", self.args.host, battery_voltage)

		battery_temperature = self.snmpclient.get("PowerNet-MIB::upsAdvBatteryTemperature.0").get_value()
		_log.debug("Device %s battery temperature is %dC", self.args.host, battery_temperature)

		battery_replace_indicator = self.snmpclient.get("PowerNet-MIB::upsAdvBatteryReplaceIndicator.0").get_value() == 2
		_log.debug("Device %s battery replace indicator is %s", self.args.host, 'on' if battery_replace_indicator else 'off')
		yield nagiosplugin.Metric('battery_replace_indicator', not battery_replace_indicator)

		battery_run_time_remaining = self.snmpclient.get("PowerNet-MIB::upsAdvBatteryRunTimeRemaining.0").get_value() / 100
		_log.debug("Device %s battery run time remaining: %ds", self.args.host, battery_run_time_remaining)

		# input
		input_voltage = self.snmpclient.get("PowerNet-MIB::upsAdvInputLineVoltage.0").get_value()
		_log.debug("Device %s input voltage is %dV", self.args.host, input_voltage)

		input_min_voltage = self.snmpclient.get("PowerNet-MIB::upsAdvInputMinLineVoltage.0").get_value()
		_log.debug("Device %s minimum input voltage is %dV", self.args.host, input_min_voltage)

		input_max_voltage = self.snmpclient.get("PowerNet-MIB::upsAdvInputMaxLineVoltage.0").get_value()
		_log.debug("Device %s maximum input voltage is %dV", self.args.host, input_max_voltage)

		input_frequency = self.snmpclient.get("PowerNet-MIB::upsAdvInputFrequency.0").get_value()
		_log.debug("Device %s input frequency is %dHz", self.args.host, input_frequency)

		# output
		output_status_namedvalues = mib_builder.mibSymbols['PowerNet-MIB']['upsBasicOutputStatus'].syntax.getNamedValues()
		output_status_value = self.snmpclient.get("PowerNet-MIB::upsBasicOutputStatus.0").get_value()
		output_status = output_status_namedvalues.getName(output_status_value)
		_log.debug("Device %s output status is %s", self.args.host, output_status)
		yield nagiosplugin.Metric('output_status', output_status)

		output_voltage = self.snmpclient.get("PowerNet-MIB::upsAdvOutputVoltage.0").get_value()
		_log.debug("Device %s output voltage is %dV", self.args.host, output_voltage)

		output_current = float(self.snmpclient.get("PowerNet-MIB::upsHighPrecOutputCurrent.0").get_value()) / 10.0
		_log.debug("Device %s output current is %.1fA", self.args.host, output_current)

		output_load = self.snmpclient.get("PowerNet-MIB::upsAdvOutputLoad.0").get_value()
		_log.debug("Device %s output load is %d%%", self.args.host, output_load)

		output_frequency = self.snmpclient.get("PowerNet-MIB::upsAdvOutputFrequency.0").get_value()
		_log.debug("Device %s output frequency is %dHz", self.args.host, output_frequency)

		output_efficiency = float(self.snmpclient.get("PowerNet-MIB::upsHighPrecOutputEfficiency.0").get_value()) / 10.0
		_log.debug("Device %s output efficiency is %.1f%%", self.args.host, output_efficiency)


@nagiosplugin.guarded
def main():
	argp = argparse.ArgumentParser()
	argp.add_argument('-v', '--verbose', action='count', default=0)
	argp.add_argument('-c', '--config', help='config file', default='/etc/check_ups_apc.conf')
	argp.add_argument('-C', '--community', help='SNMP Community', default='public')
	argp.add_argument('-H', '--host', help='Hostname or network address to check', required=True)
	argp.add_argument('-t', '--timeout', help='Check timeout', type=int, default=30)
	argp.add_argument('-s', '--snmp-timeout', help='SNMP timeout', dest='snmp_timeout', type=int, default=2)
	argp.add_argument('-r', '--retries', help='SNMP retries', type=int, default=3)
	argp.add_argument('-u', '--uptime', help='Uptime limit in minutes to create warning', type=int, default=120)
	args = argp.parse_args()

	device_defaults = dict(
		input_voltage_min_warn=215, input_voltage_max_warn=240, input_voltage_min_crit=210, input_voltage_max_crit=245,
		input_frequency_min_warn=48, input_frequency_max_warn=52, input_frequency_min_crit=47, input_frequency_max_crit=53,

		output_voltage_min_warn=215, output_voltage_max_warn=240, output_voltage_min_crit=210, output_voltage_max_crit=245,
		output_frequency_min_warn=48, output_frequency_max_warn=52, output_frequency_min_crit=47, output_frequency_max_crit=53,

		battery_capacity_min_warn=70, battery_capacity_min_crit=50,
		battery_temperature_min_warn=15, battery_temperature_max_warn=30, battery_temperature_min_crit=10, battery_temperature_max_crit=40,
	)
	config_defaults = {'general': {}, args.host: device_defaults}

	config_parser = configparser.ConfigParser(config_defaults)
	config_parser.read(args.config)

	if args.host not in config_parser.sections():
		config_parser.add_section(args.host)

	for key, value in device_defaults.items():
		if not config_parser.has_option(args.host, key):
			config_parser.set(args.host, key, str(value))

	check = nagiosplugin.Check(UPSAPC(args))
	check.add(SNMPContext('reachable'))
	check.add(BoolContext('battery_replace_indicator', ok_text="Battery OK", crit_text="Battery needs replacement"))

	# input
	check.add(nagiosplugin.ScalarContext('input_voltage',
											warning='%i:%i' % (config_parser.getint(args.host, 'input_voltage_min_warn'), config_parser.getint(args.host, 'input_voltage_max_warn')),
											critical='%i:%i' % (config_parser.getint(args.host, 'input_voltage_min_crit'), config_parser.getint(args.host, 'input_voltage_max_crit'))))

	check.add(nagiosplugin.ScalarContext('input_frequency',
											warning='%i:%i' % (config_parser.getint(args.host, 'input_frequency_min_warn'), config_parser.getint(args.host, 'input_frequency_max_warn')),
											critical='%i:%i' % (config_parser.getint(args.host, 'input_frequency_min_crit'), config_parser.getint(args.host, 'input_frequency_max_crit'))))

	# output
	check.add(nagiosplugin.ScalarContext('output_voltage',
											warning='%i:%i' % (config_parser.getint(args.host, 'output_voltage_min_warn'), config_parser.getint(args.host, 'output_voltage_max_warn')),
											critical='%i:%i' % (config_parser.getint(args.host, 'output_voltage_min_crit'), config_parser.getint(args.host, 'output_voltage_max_crit'))))

	check.add(nagiosplugin.ScalarContext('output_frequency',
											warning='%i:%i' % (config_parser.getint(args.host, 'output_frequency_min_warn'), config_parser.getint(args.host, 'output_frequency_max_warn')),
											critical='%i:%i' % (config_parser.getint(args.host, 'output_frequency_min_crit'), config_parser.getint(args.host, 'output_frequency_max_crit'))))

	output_status_ok_values = [
		'onLine',
		'hotStandby',
	]
	output_status_warn_values = [
		'onBattery',
		'onSmartBoost',  # under-voltage boost
		'softwareBypass',
		'switchedBypass',
		'rebooting',
		'onSmartTrim',  # over-voltage trim
		'ecoMode',  # bypass
		'staticBypassStandby',
	]
	output_status_crit_values = [
		'timedSleeping',  # output off (planned)
		'sleepingUntilPowerReturn',
		'hardwareFailureBypass',
		'emergencyStaticBypass',
		'off',
		'powerSavingMode',  # auto-off
	]
	check.add(ElementContext('output_status', ok_values=output_status_ok_values, warn_values=output_status_warn_values, crit_values=output_status_crit_values))

	# battery
	check.add(nagiosplugin.ScalarContext('battery_capacity',
											warning='%i:100' % (config_parser.getint(args.host, 'battery_capacity_min_warn')),
											critical='%i:100' % (config_parser.getint(args.host, 'battery_capacity_min_crit'))))

	check.add(nagiosplugin.ScalarContext('battery_temperature',
											warning='%i:%i' % (config_parser.getint(args.host, 'battery_temperature_min_warn'), config_parser.getint(args.host, 'battery_temperature_max_warn')),
											critical='%i:%i' % (config_parser.getint(args.host, 'battery_temperature_min_crit'), config_parser.getint(args.host, 'battery_temperature_max_crit'))))

	check.add(nagiosplugin.ScalarContext('sysuptime', warning='@%i:%i' % (0, args.uptime)))

	check.main(args.verbose, timeout=args.timeout)

if __name__ == "__main__":
	main()
